\section{Methods}
In this section we describe the development methods and the tools which are considered to be used in this project.
A choice is given in both of these areas along with a reasoning for the choice.

\subsection{Development Method}
In this project we are four groups working together.
For this collaboration to work properly it is important that we have a common understanding of the development method which is used.
Different development methods are presented here and a single one is chosen to be used in this project.

\subsubsection{Considered Methods}
A common division of development methods is into traditional and agile.
In general traditional methods follow a structured plan, where every task is handled in a single unit and the result is not changed afterwards \cite[sec.~2.7]{Poppendieck00}.
This is inspired by the construction industry, where these methods originate.
Projects using agile methods are developed in iterations, where some part of the product is developed in every iteration \cite[p.~25]{Larman04}.
This should help cope with the changes that the users might pose during the development.
Some methods can have characteristics from both categories.
The development methods considered in this project are: Extreme Programming, Scrum, and Waterfall.
These are presented shortly in the following.

\paragraph{Extreme Programming}
Extreme Programming (XP) is an agile development method that consists of a series of 12 recommended core practices \cite[p.~137]{Larman04}.
These include but are not limited to: Frequent refactoring, pair programming, and  whole team together.
The core of XP is to find every practice that is considered good and taking it to the extreme, e.g. since code reviews are good, do them all the time through pair programming.
Kent Beck, the creator of XP, states that in general all the practices of XP should be applied because they compensate and support each other \cite[p.~156-157]{Larman04}.

When using XP, the development is to progress in iterations of one to three weeks each.
An iteration should not be planned until right before the start of it, where the onsite customer should help prioritize which features should be implemented in the given iteration and the programmers estimate the time to implement them.
This process is called ``Iteration planning game''.

There are roles assigned to different people involved in the project \cite[p.~145]{Larman04}.
These roles are: Customer, programmer, tester, coach, tracker, consultant.
All these roles are important, but Larman stresses the need for an onsite customer or at least a onsite customer proxies \cite[p.~152-156]{Larman04}.

\paragraph{Scrum}
Scrum is an agile development method that utilizes a number of iterations of development cycles.
These development cycles are known as sprints.
A sprint usually has a length of a very low number of weeks.
A sprint backlog is created prior to the sprint. 
This backlog consists of the features, ordered by priority, that should be implemented during the sprint.
During the sprint the sprint backlog cannot be changed.
If all the features in the sprint backlog are not implemented during the sprint they are moved to the product backlog, which is a list of the features that should be implemented in the future.
In scrum there are different roles. 
There should be a product owner, whose task is to meet the costumer's interests. 
These interests should be formalized and prioritized in the product backlog.
There should also be a scrum master. 
A scrum master should server as a link between the development team and any external individuals.
It is the scrum master's task to ensure that the development team is not disturbed.
The development team is usually small, and their task is to design, analyse, and implement the features from the backlogs.
Every day the scrum team holds a short meeting where they say what they have done since the preceeding day, what they plan on doing the present day, and any problems they are having.


\paragraph{Waterfall}
A project following the Waterfall method is divided into a number of phases.
The number of phases in a Waterfall development process is not exact.
Depending on the person asked more or less phases may be suggested e.g. marry Poppendieck is refering to six phases \cite{Poppendieck00}.
Waterfall is strictly traditional, since it in its pure form does not allow to move ``backwards'' in the life cycle.
Where backwards refer to moving back into the analysis phase once the design has begun.
This suggests a big and heavy up front design plan that is to be follow when finished.

\subsection{Choosing a Development Method}
The following list shows the characteristics that will be used to determine the development method which should be used in this project.
\begin{enumerate}
	\item 14 persons in four groups \label{enum:groupSize}
	\item Diverse target group \label{enum:targetGroup}
	\item No on-site costumer \label{enum:onsite}
	\item Hard deadline \label{enum:deadline}
	\item Passed on project \label{enum:passed}
	\item Known framework and platform \label{enum:framework}
	\item Education environment \label{enum:education}
	\item Not full-time development \label{enum:halftime}
	\item No manager/Project owner \label{enum:manager}
	\item No shared working room \label{enum:room}
\end{enumerate}
We will use a development approach similar to Scrum of Scrums.
The reason for this is three fold.
First of all we have a diverse target group (point \ref{enum:targetGroup}), that may make big up front analysis and design difficult.
This leads us to choose an agile method due to ``I know it when I see it'' (IKIWISI).

Secondly we are 14 group members divided into four groups (as point \ref{enum:groupSize} states) which is not handled very well in other agile methods such as XP, which dictates that all the developers should be in the same room. 
This is not the case for us as point \ref{enum:room} states.

The third reason is that we have a hard deadline (point \ref{enum:deadline}), which means that we have to hand in our project at a specific date.
Scrum of Scrums suggests that iterations (sprints) are time-boxed, which is ideal for us since we can cut less important features instead of missing the deadline.
This is also supported by point \ref{enum:passed}, because the end product is a working release although some features may have been cut.
The features cut may then be suggested to the group which is to take up this project next year.


\subsubsection{Refining SCRUM}
As point \ref{enum:manager} and \ref{enum:onsite} states, we have neither a project manager nor an available on-site customer.
We will handle the missing on-site customer by having shorter iterations and contacting the customers whenever an iteration is over.
Scrum of Scrums dictates that there should be a Scrum master in each subgroup.
Since none of us has used Scrum before, none of us are qualified to be Scrum master/project manager.
We are in an educational situation (see point \ref{enum:education}) so we will strive to allow every member to try to be Scrum master for a shorter time period.
This may not be ideal, but we consider it to be more important that every member of the subgroups tries to have the responsibility of a Scrum master than having only one member trying it and learning it well.

\subsection{Tools}
A series of tools are used in creation of this project.
These tools are briefly described in this section.
The tools that needs to be chosen must indeed complete some task, the tasks that needs a tool are: Version control, bug tracking, code documentation, and testing.

\subsubsection{Version Control}
All of us have been using subversion (SVN) in previous projects as the version controlling system.
SVN is a centralized solution \cite{subversion} with a single repository that the group members can update from and commit changes to.
This project does, however, differ from previous project with respect to the organization of groups; we are not one group of $x$ individuals, but rather one group consisting of some smaller subgroups, again consisting of individual persons.
This has lead us to choose a distributed solution rather than a centralized one.

The solutions considered are the distributed systems Git and Mercurial (Hg).
These systems are quite similar and the essential difference is that Hg is simpler than Git.
A few of us have been using Hg and none of us have used Git, which leads us to choose Hg, such that we a little knowledge of the chosen system.

\subsubsection{Bug Tracking}
We need to have some way of communicating and tracking the defects or ``bugs'' that we will run into during our project.
The tools that we are considering to use for bug tracking are Bugzilla and Eventum.


\subsubsection{Code Documentation}
We want our documentation of our code to be as close to the code as possible.
In particular we do not want to go back and forth between the source code and some other program when we are writing new functionality and documenting it.
We want to use a tool like PHPDocumentor \cite{phpdocumentor} or PHPXref \cite{phpxref} to handle our documentation, since both of these reads comments in the source code and use it as documentation.
This gives us the ability to write code and documentation in the same file, which is what we want.
The syntax that both of these tools use is the same, which means that as long as we adhere to this syntax we can use either tool to generate documentation.

The difference between the two tools is that PHPDocumentor focus on giving a more diverse set of final documents (different HTML and PDF templates), where PHPXref focus more on the reference between classes, function, etc.
We use both tools such that we and the group that is to take up this project next year can choose the documentation they prefer.


\subsubsection{Testing}
The test tool that we want to use should be easily adapted by us, which leads us to look at tools using PHP, since that is the language we will be using to develop this project.
We also want the tests to survive after our work on the project ends, in particular the groups that is to take up this project next year should be able to use our test cases again.
We will be using the build in testing framework of Moodle \cite{moodletest}, which is based on SimpleTest \cite{simpletest}.
This should ensure that the test cases can be used next year as well and perhaps be part of the final product, should it ever be realeased to the public.










